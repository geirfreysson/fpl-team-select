#!/usr/bin/env python3
"""
FPL Squad Selection via 0-1 Integer Linear Programming (Multi-dimensional Knapsack)

This script implements an optimal Fantasy Premier League team selection algorithm
using Integer Linear Programming to maximize projected points while respecting
all FPL constraints.

USAGE:
    # Run with default settings (maximize points, regular starters only, max 1 per team per position, exclude injury risks)
    uv run python fpl_team_selector.py
    
    # Include fixture difficulty in selection (higher weight = more fixture influence)
    uv run python fpl_team_selector.py --fixture-weighting 0.3
    
    # Include last season performance (higher weight = more historical influence)
    uv run python fpl_team_selector.py --last-season-weighting 0.4
    
    # Balanced approach: current form + fixtures + history
    uv run python fpl_team_selector.py --fixture-weighting 0.3 --last-season-weighting 0.4
    
    # Heavy historical weighting (favors proven performers from last season)
    uv run python fpl_team_selector.py --last-season-weighting 0.7
    
    # Maximize budget usage instead of points
    uv run python fpl_team_selector.py --objective max_spend
    
    # Allow rotation players who haven't started all games
    uv run python fpl_team_selector.py --allow-rotation
    
    # Disable max 1 player per team per position constraint
    uv run python fpl_team_selector.py --no-max-one-per-team-position
    
    # Allow players with injury concerns (doubtful/injured)
    uv run python fpl_team_selector.py --allow-injury-risk
    
    # Conservative approach with all features enabled
    uv run python fpl_team_selector.py --fixture-weighting 0.2 --last-season-weighting 0.3
    
    # Run with all constraints disabled (original algorithm)
    uv run python fpl_team_selector.py --allow-rotation --no-max-one-per-team-position --allow-injury-risk
    
    # Optimize starting XI only with £20M bench budget limit
    uv run python fpl_team_selector.py --bench-budget 20.0 --optimize-starting-xi
    
    # Combined approach: fixtures + history + bench budget control
    uv run python fpl_team_selector.py --fixture-weighting 0.3 --last-season-weighting 0.4 --bench-budget 18.5 --optimize-starting-xi
    
    # Run test with dummy data to verify algorithm
    uv run python fpl_team_selector.py --test
    
    # Use custom data directory (default: fpl_data/fpl_data)
    uv run python fpl_team_selector.py --data-dir /path/to/your/data
    
    # Show help
    uv run python fpl_team_selector.py --help

REQUIREMENTS:
    - OR-Tools library (installed via: uv add ortools)
    - FPL data files in parquet/JSON format (generated by process_fpl_data.py)
"""

import pandas as pd
import json
from typing import Dict, List, Tuple, Optional
import argparse
from ortools.linear_solver import pywraplp
import sys
from pathlib import Path

class FPLTeamSelector:
    """
    FPL Team Selection optimizer using Integer Linear Programming.
    
    Maximizes projected points subject to:
    - Budget constraint (£100m)
    - Position requirements (2 GK, 5 DEF, 5 MID, 3 FWD)
    - Squad size (15 players)
    - Club limit (max 3 per team)
    """
    
    def __init__(self, data_dir: str = "fpl_data/fpl_data"):
        """Initialize with FPL data directory."""
        self.data_dir = Path(data_dir)
        self.players = None
        self.teams = None
        self.load_data()
    
    def load_data(self):
        """Load FPL data from parquet and JSON files."""
        try:
            # Load player data
            elements_path = self.data_dir / "elements.parquet"
            self.players = pd.read_parquet(elements_path)
            
            # Load team data
            teams_path = self.data_dir / "teams.json"
            with open(teams_path, 'r') as f:
                teams_list = json.load(f)
            
            # Create team lookup dictionary
            self.teams = {team['id']: team for team in teams_list}
            
            # Load fixture data for next matches display  
            fixtures_path = self.data_dir / "fixtures.parquet"
            self.fixtures = pd.read_parquet(fixtures_path)
            
            # Load historical data for last season points
            history_path = self.data_dir / "player_history_past.parquet"
            self.player_history = pd.read_parquet(history_path)
            
            # Extract last season (2023/24) data and normalize to per-gameweek
            self.last_season_data = self.player_history[
                self.player_history['season_name'] == '2023/24'
            ].copy()
            
            if len(self.last_season_data) > 0:
                # Normalize to points per gameweek (38 gameweeks in full season)
                self.last_season_data['points_per_gw_last_season'] = (
                    self.last_season_data['total_points'] / 38.0
                )
                print(f"Loaded {len(self.players)} players, {len(self.teams)} teams, and {len(self.last_season_data)} players with 2023/24 history")
            else:
                print(f"Loaded {len(self.players)} players and {len(self.teams)} teams (no historical data available)")
            
        except FileNotFoundError as e:
            print(f"Error: Could not find data files in {self.data_dir}")
            print(f"Make sure you have run the data processing script first")
            raise e
    
    def get_next_fixtures(self, team_id: int, num_fixtures: int = 3) -> str:
        """Get next N fixtures for a team formatted as opponent codes with H/A."""
        upcoming_fixtures = self.fixtures[self.fixtures['finished'] == False].copy()
        upcoming_fixtures = upcoming_fixtures.sort_values(['event', 'id'])
        
        team_fixtures = []
        for _, fixture in upcoming_fixtures.iterrows():
            if fixture['team_h'] == team_id:  # Team at home
                opponent_code = self.teams[fixture['team_a']]['short_name']
                team_fixtures.append(f"{opponent_code}(H)")
            elif fixture['team_a'] == team_id:  # Team away  
                opponent_code = self.teams[fixture['team_h']]['short_name']
                team_fixtures.append(f"{opponent_code}(A)")
            
            if len(team_fixtures) >= num_fixtures:
                break
        
        # Pad with "?" if not enough fixtures
        while len(team_fixtures) < num_fixtures:
            team_fixtures.append("?(?)") 
            
        return ", ".join(team_fixtures)
    
    def prepare_player_data(self, require_all_starts: bool = True, exclude_injury_risk: bool = True, 
                           fixture_weighting: float = 0.0, last_season_weighting: float = 0.0) -> pd.DataFrame:
        """
        Prepare player data for optimization.
        
        Args:
            require_all_starts: If True, only include players who have started all games
            exclude_injury_risk: If True, exclude players with injury concerns
            fixture_weighting: Weight for fixture difficulty (0.0-1.0)
            last_season_weighting: Weight for last season performance (0.0-1.0)
        
        Returns DataFrame with columns:
        - id, name, position, team, price, proj_points, fixture_adjusted_points, last_season_adjusted_points, starts, has_started_all, is_injury_risk
        """
        # Filter out unavailable players
        available_players = self.players[
            (self.players['can_select'] == True) & 
            (self.players['can_transact'] == True)
        ].copy()
        
        # Calculate expected starts (based on finished fixtures)
        # From our analysis: 2 gameweeks completed = 2 expected starts for regular starters
        expected_starts = 2
        
        # Map element_type to position names
        position_map = {1: 'GKP', 2: 'DEF', 3: 'MID', 4: 'FWD'}
        
        # Identify injury risk players
        # Status codes: 'a' = available, 'd' = doubtful, 'i' = injured, 'u' = unavailable, 'n' = not available, 's' = suspended
        # Also consider players with <75% chance of playing as risky
        injury_risk_condition = (
            (available_players['status'] != 'a') |  # Non-available status
            (available_players['chance_of_playing_next_round'].notna() & 
             (available_players['chance_of_playing_next_round'] < 75.0))  # <75% chance of playing
        )
        
        # Calculate fixture-adjusted points
        # Lower fixture difficulty = easier games = higher adjusted points
        # Fixture difficulty ranges from 2.6 (easiest) to 3.6 (hardest)
        # We'll invert it so easier fixtures boost points more
        base_points = available_players['total_points'].astype(float)
        
        if fixture_weighting > 0.0:
            # Normalize fixture difficulty to 0-1 range (1 = easiest, 0 = hardest)
            fixture_difficulty = available_players['avg_fixture_difficulty_5']
            max_difficulty = 3.6  # Hardest fixtures
            min_difficulty = 2.6  # Easiest fixtures
            
            # Invert and normalize: easier fixtures = higher multiplier
            fixture_ease = (max_difficulty - fixture_difficulty) / (max_difficulty - min_difficulty)
            
            # Create fixture adjustment: ranges from 0.5 to 1.5
            # Easy fixtures get 1.5x multiplier, hard fixtures get 0.5x
            fixture_multiplier = 0.5 + fixture_ease
            
            # Apply weighted adjustment
            fixture_adjusted_points = base_points * (1 + fixture_weighting * (fixture_multiplier - 1))
            
            print(f"Applying fixture difficulty weighting (weight: {fixture_weighting:.1f})...")
            print(f"Fixture multiplier range: {fixture_multiplier.min():.2f} - {fixture_multiplier.max():.2f}")
        else:
            fixture_adjusted_points = base_points
            
        # Calculate last season adjusted points
        current_gameweeks = 2
        
        if last_season_weighting > 0.0:
            print(f"Applying last season weighting (weight: {last_season_weighting:.1f})...")
            
            # Merge with last season data
            last_season_lookup = self.last_season_data.set_index('player_id')['points_per_gw_last_season'].to_dict()
            
            # Calculate current points per gameweek from fixture-adjusted points (not base points)
            current_points_per_gw = fixture_adjusted_points / current_gameweeks
            
            # Get last season points per gameweek (0 if no data)
            last_season_points_per_gw = available_players['id'].map(last_season_lookup).fillna(0.0)
            
            # Combine current (fixture-adjusted) and last season rates
            combined_points_per_gw = (
                (1 - last_season_weighting) * current_points_per_gw + 
                last_season_weighting * last_season_points_per_gw
            )
            
            # Convert back to current season scale (2 gameweeks)
            last_season_adjusted_points = combined_points_per_gw * current_gameweeks
            
            players_with_history = (last_season_points_per_gw > 0).sum()
            print(f"Applied last season data to {players_with_history} players with 2023/24 history")
        else:
            last_season_adjusted_points = fixture_adjusted_points
            last_season_points_per_gw = pd.Series(0.0, index=available_players.index)
        
        # Prepare the data
        player_data = pd.DataFrame({
            'id': available_players['id'],
            'name': available_players['web_name'],
            'position': available_players['element_type'].map(position_map),
            'team': available_players['team'],
            'price': available_players['now_cost'] / 10.0,  # Convert to millions
            'proj_points': base_points,  # Original points
            'fixture_adjusted_points': fixture_adjusted_points,  # Points adjusted for fixtures
            'last_season_adjusted_points': last_season_adjusted_points,  # Points adjusted for last season
            'current_points_per_gw': base_points / current_gameweeks,
            'last_season_points_per_gw': last_season_points_per_gw,
            'avg_fixture_difficulty_5': available_players['avg_fixture_difficulty_5'],
            'starts': available_players['starts'],
            'minutes': available_players['minutes'],
            'has_started_all': available_players['starts'] >= expected_starts,
            'is_injury_risk': injury_risk_condition,
            'status': available_players['status'],
            'chance_of_playing': available_players['chance_of_playing_next_round'],
            'news': available_players['news']
        })
        
        # Add team names and next fixtures for display
        player_data['team_name'] = player_data['team'].map(
            lambda x: self.teams.get(x, {}).get('short_name', f'Team{x}')
        )
        player_data['next_3_fixtures'] = player_data['team'].apply(
            lambda x: self.get_next_fixtures(x, 3)
        )
        
        # Filter to only regular starters if requested
        if require_all_starts:
            print(f"Filtering to players who have started all {expected_starts} games...")
            before_count = len(player_data)
            player_data = player_data[player_data['has_started_all']].copy()
            after_count = len(player_data)
            print(f"Regular starters filter: {before_count} -> {after_count} ({before_count - after_count} removed)")
        
        # Filter out injury risk players if requested
        if exclude_injury_risk:
            print("Filtering out players with injury concerns...")
            before_count = len(player_data)
            injury_risk_players = player_data[player_data['is_injury_risk']]
            if len(injury_risk_players) > 0:
                print(f"Injury risk players being excluded:")
                for _, player in injury_risk_players.iterrows():
                    status_text = f"Status: {player['status']}"
                    chance_text = f"Chance: {player['chance_of_playing']}%" if pd.notna(player['chance_of_playing']) else ""
                    news_text = f"News: {player['news']}" if pd.notna(player['news']) and player['news'] != "" else ""
                    print(f"  {player['name']} ({player['team_name']}) - {status_text} {chance_text} {news_text}".strip())
            
            player_data = player_data[~player_data['is_injury_risk']].copy()
            after_count = len(player_data)
            print(f"Injury risk filter: {before_count} -> {after_count} ({before_count - after_count} removed)")
        
        return player_data.reset_index(drop=True)
    
    def solve_team_selection(self, objective: str = 'max_points', require_all_starts: bool = True, 
                           max_per_team_per_position: bool = True, exclude_injury_risk: bool = True,
                           fixture_weighting: float = 0.0, last_season_weighting: float = 0.0,
                           bench_budget: Optional[float] = None, optimize_starting_xi: bool = False) -> Dict:
        """
        Solve the FPL team selection problem using Integer Linear Programming.
        
        Args:
            objective: Either 'max_points' or 'max_spend'
            require_all_starts: If True, only consider players who started all games
            max_per_team_per_position: If True, max 1 player per team per position
            exclude_injury_risk: If True, exclude players with injury concerns
            fixture_weighting: Weight for fixture difficulty (0.0-1.0, higher = more fixture influence)
            last_season_weighting: Weight for last season performance (0.0-1.0, higher = more historical influence)
            bench_budget: Maximum budget for bench players (None = no limit)
            optimize_starting_xi: If True, optimize starting XI points only, ignore bench
        
        Returns:
            Dictionary with solution details
        """
        players_df = self.prepare_player_data(require_all_starts, exclude_injury_risk, fixture_weighting, last_season_weighting)
        
        # Create the solver
        solver = pywraplp.Solver.CreateSolver('SCIP')
        if not solver:
            print("Error: Could not create solver. Make sure OR-Tools is installed.")
            return None
        
        # Decision variables: x[i] = 1 if player i is selected, 0 otherwise
        x = {}
        for i in players_df.index:
            x[i] = solver.IntVar(0, 1, f'x_{i}')
        
        # Additional decision variables for starting XI (if bench budget control enabled)
        s = {}
        if bench_budget is not None or optimize_starting_xi:
            print("Adding starting XI decision variables...")
            for i in players_df.index:
                s[i] = solver.IntVar(0, 1, f's_{i}')
        
        # Constraint 1: Squad size = 15
        solver.Add(sum(x[i] for i in players_df.index) == 15)
        
        # Constraint 2: Budget <= £100m
        solver.Add(
            sum(players_df.loc[i, 'price'] * x[i] for i in players_df.index) <= 100.0
        )
        
        # Constraint 3: Position requirements
        position_requirements = {'GKP': 2, 'DEF': 5, 'MID': 5, 'FWD': 3}
        
        for pos, required_count in position_requirements.items():
            pos_players = players_df[players_df['position'] == pos].index
            solver.Add(sum(x[i] for i in pos_players) == required_count)
        
        # Constraint 4: Club limit (max 3 per team)
        for team_id in players_df['team'].unique():
            team_players = players_df[players_df['team'] == team_id].index
            if len(team_players) > 0:
                solver.Add(sum(x[i] for i in team_players) <= 3)
        
        # Constraint 5: Max 1 player per team per position (if enabled)
        if max_per_team_per_position:
            print("Adding constraint: max 1 player per team per position")
            constraint_count = 0
            for team_id in players_df['team'].unique():
                for position in ['GKP', 'DEF', 'MID', 'FWD']:
                    team_pos_players = players_df[
                        (players_df['team'] == team_id) & 
                        (players_df['position'] == position)
                    ].index
                    if len(team_pos_players) > 1:  # Only add constraint if > 1 player
                        solver.Add(sum(x[i] for i in team_pos_players) <= 1)
                        constraint_count += 1
            print(f"Added {constraint_count} team-position constraints")
        
        # Starting XI constraints (if bench budget control or optimization enabled)
        if bench_budget is not None or optimize_starting_xi:
            print("Adding starting XI formation constraints...")
            
            # Get position player indices
            gk_players = players_df[players_df['position'] == 'GKP'].index
            def_players = players_df[players_df['position'] == 'DEF'].index
            mid_players = players_df[players_df['position'] == 'MID'].index
            fwd_players = players_df[players_df['position'] == 'FWD'].index
            
            # Starting XI formation constraints (1 GK, 3-5 DEF, 2-5 MID, 1-3 FWD)
            solver.Add(sum(s[i] for i in gk_players) == 1)  # Exactly 1 GK
            solver.Add(sum(s[i] for i in def_players) >= 3)  # At least 3 DEF
            solver.Add(sum(s[i] for i in def_players) <= 5)  # At most 5 DEF
            solver.Add(sum(s[i] for i in mid_players) >= 2)  # At least 2 MID
            solver.Add(sum(s[i] for i in mid_players) <= 5)  # At most 5 MID
            solver.Add(sum(s[i] for i in fwd_players) >= 1)  # At least 1 FWD
            solver.Add(sum(s[i] for i in fwd_players) <= 3)  # At most 3 FWD
            
            # Exactly 11 starters
            solver.Add(sum(s[i] for i in players_df.index) == 11)
            
            # Logical constraint: Can't start if not in squad
            for i in players_df.index:
                solver.Add(s[i] <= x[i])
            
            # Bench budget constraint (if specified)
            if bench_budget is not None:
                print(f"Adding bench budget constraint: £{bench_budget}m")
                bench_cost = sum(players_df.loc[i, 'price'] * (x[i] - s[i]) for i in players_df.index)
                solver.Add(bench_cost <= bench_budget)
        
        # Set objective
        if objective == 'max_points':
            if optimize_starting_xi and s:
                print("Optimizing starting XI points only...")
                # Maximize last season adjusted points for starting XI only
                solver.Maximize(
                    sum(players_df.loc[i, 'last_season_adjusted_points'] * s[i] for i in players_df.index)
                )
            else:
                # Maximize last season adjusted points (includes fixture adjustment if enabled)
                solver.Maximize(
                    sum(players_df.loc[i, 'last_season_adjusted_points'] * x[i] for i in players_df.index)
                )
        elif objective == 'max_spend':
            if optimize_starting_xi and s:
                print("Maximizing starting XI spend...")
                # Maximize starting XI spend with points as tiebreaker
                epsilon = 1e-6
                solver.Maximize(
                    sum((players_df.loc[i, 'price'] + epsilon * players_df.loc[i, 'last_season_adjusted_points']) * s[i] 
                        for i in players_df.index)
                )
            else:
                # Maximize spend with last season adjusted points as tiebreaker
                epsilon = 1e-6
                solver.Maximize(
                    sum((players_df.loc[i, 'price'] + epsilon * players_df.loc[i, 'last_season_adjusted_points']) * x[i] 
                        for i in players_df.index)
                )
        
        # Solve
        print(f"Solving FPL team selection with objective: {objective}")
        status = solver.Solve()
        
        if status == pywraplp.Solver.OPTIMAL:
            return self._extract_solution(solver, x, players_df, objective, status, fixture_weighting, last_season_weighting, s, bench_budget, optimize_starting_xi)
        elif status == pywraplp.Solver.FEASIBLE:
            print("Warning: Found feasible but not optimal solution")
            return self._extract_solution(solver, x, players_df, objective, status, fixture_weighting, last_season_weighting, s, bench_budget, optimize_starting_xi)
        else:
            print("Error: No feasible solution found!")
            print("This might indicate:")
            print("- Budget is too restrictive")
            print("- Not enough players available in some positions")
            print("- Club constraints are too tight")
            return None
    
    def _extract_solution(self, solver, x, players_df, objective, status, fixture_weighting, last_season_weighting, s=None, bench_budget=None, optimize_starting_xi=False) -> Dict:
        """Extract and format the solution."""
        selected_indices = [i for i in players_df.index if x[i].solution_value() > 0.5]
        selected_players = players_df.loc[selected_indices].copy()
        
        # Extract starting XI and bench if variables exist
        starting_xi_indices = []
        bench_indices = []
        starting_xi_players = pd.DataFrame()
        bench_players = pd.DataFrame()
        formation = ""
        
        if s:
            starting_xi_indices = [i for i in players_df.index if s[i].solution_value() > 0.5]
            bench_indices = [i for i in selected_indices if i not in starting_xi_indices]
            starting_xi_players = players_df.loc[starting_xi_indices].copy()
            bench_players = players_df.loc[bench_indices].copy()
            
            # Calculate formation (e.g., "3-5-2")
            starting_positions = starting_xi_players['position'].value_counts()
            def_count = starting_positions.get('DEF', 0)
            mid_count = starting_positions.get('MID', 0) 
            fwd_count = starting_positions.get('FWD', 0)
            formation = f"{def_count}-{mid_count}-{fwd_count}"
        
        # Calculate totals
        total_price = selected_players['price'].sum()
        total_proj_points = selected_players['proj_points'].sum()
        total_fixture_adjusted_points = selected_players['fixture_adjusted_points'].sum()
        total_last_season_adjusted_points = selected_players['last_season_adjusted_points'].sum()
        avg_fixture_difficulty = selected_players['avg_fixture_difficulty_5'].mean()
        avg_current_points_per_gw = selected_players['current_points_per_gw'].mean()
        avg_last_season_points_per_gw = selected_players['last_season_points_per_gw'].mean()
        
        # Group by position
        by_position = {}
        for pos in ['GKP', 'DEF', 'MID', 'FWD']:
            pos_players = selected_players[selected_players['position'] == pos]
            by_position[pos] = pos_players[['id', 'name', 'team_name', 'price', 'proj_points', 
                                          'fixture_adjusted_points', 'last_season_adjusted_points',
                                          'current_points_per_gw', 'last_season_points_per_gw',
                                          'avg_fixture_difficulty_5', 'next_3_fixtures']].to_dict('records')
        
        # Group by team
        by_team_counts = selected_players['team_name'].value_counts().to_dict()
        
        # Calculate starting XI and bench totals if applicable
        starting_xi_stats = {}
        bench_stats = {}
        
        if s:
            # Starting XI stats
            starting_xi_stats = {
                'total_price': round(starting_xi_players['price'].sum(), 1) if len(starting_xi_players) > 0 else 0.0,
                'total_proj_points': round(starting_xi_players['proj_points'].sum(), 1) if len(starting_xi_players) > 0 else 0.0,
                'total_fixture_adjusted_points': round(starting_xi_players['fixture_adjusted_points'].sum(), 1) if len(starting_xi_players) > 0 else 0.0,
                'total_last_season_adjusted_points': round(starting_xi_players['last_season_adjusted_points'].sum(), 1) if len(starting_xi_players) > 0 else 0.0,
                'count': len(starting_xi_players),
                'formation': formation
            }
            
            # Bench stats
            bench_stats = {
                'total_price': round(bench_players['price'].sum(), 1) if len(bench_players) > 0 else 0.0,
                'total_proj_points': round(bench_players['proj_points'].sum(), 1) if len(bench_players) > 0 else 0.0,
                'total_fixture_adjusted_points': round(bench_players['fixture_adjusted_points'].sum(), 1) if len(bench_players) > 0 else 0.0,
                'total_last_season_adjusted_points': round(bench_players['last_season_adjusted_points'].sum(), 1) if len(bench_players) > 0 else 0.0,
                'count': len(bench_players)
            }
        
        solution = {
            'selected_ids': selected_players['id'].tolist(),
            'selected_players': selected_players.to_dict('records'),
            'total_price': round(total_price, 1),
            'total_proj_points': round(total_proj_points, 1),
            'total_fixture_adjusted_points': round(total_fixture_adjusted_points, 1),
            'total_last_season_adjusted_points': round(total_last_season_adjusted_points, 1),
            'avg_fixture_difficulty': round(avg_fixture_difficulty, 2),
            'avg_current_points_per_gw': round(avg_current_points_per_gw, 2),
            'avg_last_season_points_per_gw': round(avg_last_season_points_per_gw, 2),
            'by_position': by_position,
            'by_team_counts': by_team_counts,
            'objective': objective,
            'fixture_weighting': fixture_weighting,
            'last_season_weighting': last_season_weighting,
            'bench_budget': bench_budget,
            'optimize_starting_xi': optimize_starting_xi,
            'starting_xi_stats': starting_xi_stats,
            'bench_stats': bench_stats,
            'starting_xi_players': starting_xi_players.to_dict('records') if len(starting_xi_players) > 0 else [],
            'bench_players': bench_players.to_dict('records') if len(bench_players) > 0 else [],
            'solver_status': 'OPTIMAL' if status == pywraplp.Solver.OPTIMAL else 'FEASIBLE'
        }
        
        return solution
    
    def validate_solution(self, solution: Dict) -> Dict[str, bool]:
        """
        Validate that the solution meets all FPL constraints.
        
        Returns dictionary of validation results.
        """
        if not solution:
            return {'valid': False, 'error': 'No solution provided'}
        
        selected_df = pd.DataFrame(solution['selected_players'])
        
        validations = {}
        
        # Check squad size
        validations['squad_size'] = len(selected_df) == 15
        
        # Check budget
        validations['budget'] = solution['total_price'] <= 100.0
        
        # Check positions
        position_counts = selected_df['position'].value_counts().to_dict()
        validations['positions'] = (
            position_counts.get('GKP', 0) == 2 and
            position_counts.get('DEF', 0) == 5 and
            position_counts.get('MID', 0) == 5 and
            position_counts.get('FWD', 0) == 3
        )
        
        # Check club limits
        team_counts = selected_df['team_name'].value_counts().to_dict()
        validations['club_limits'] = all(count <= 3 for count in team_counts.values())
        
        # Check starting XI formation if applicable
        validations['starting_xi_valid'] = True
        if solution.get('starting_xi_players'):
            starting_xi_df = pd.DataFrame(solution['starting_xi_players'])
            if len(starting_xi_df) > 0:
                starting_xi_positions = starting_xi_df['position'].value_counts().to_dict()
                validations['starting_xi_valid'] = (
                    len(starting_xi_df) == 11 and
                    starting_xi_positions.get('GKP', 0) == 1 and
                    starting_xi_positions.get('DEF', 0) >= 3 and starting_xi_positions.get('DEF', 0) <= 5 and
                    starting_xi_positions.get('MID', 0) >= 2 and starting_xi_positions.get('MID', 0) <= 5 and
                    starting_xi_positions.get('FWD', 0) >= 1 and starting_xi_positions.get('FWD', 0) <= 3
                )
            
        # Check bench budget if applicable  
        validations['bench_budget_valid'] = True
        if solution.get('bench_budget') is not None:
            bench_cost = solution.get('bench_stats', {}).get('total_price', 0.0)
            validations['bench_budget_valid'] = bench_cost <= solution['bench_budget']
        
        # Overall validity
        validations['valid'] = all([
            validations['squad_size'],
            validations['budget'],
            validations['positions'],
            validations['club_limits'],
            validations['starting_xi_valid'],
            validations['bench_budget_valid']
        ])
        
        return validations
    
    def print_solution(self, solution: Dict):
        """Pretty print the solution."""
        if not solution:
            print("No solution to display")
            return
        
        print("\n" + "="*60)
        print(f"FPL OPTIMAL TEAM SELECTION ({solution['objective'].upper()})")
        print("="*60)
        
        print(f"Total Cost: £{solution['total_price']}m / £100.0m")
        print(f"Total Projected Points: {solution['total_proj_points']}")
        
        if solution.get('fixture_weighting', 0.0) > 0:
            print(f"Fixture-Adjusted Points: {solution['total_fixture_adjusted_points']}")
            print(f"Average Fixture Difficulty: {solution['avg_fixture_difficulty']} (1=easiest, 5=hardest)")
            print(f"Fixture Weighting: {solution['fixture_weighting']}")
            
        if solution.get('last_season_weighting', 0.0) > 0:
            print(f"Last Season Adjusted Points: {solution['total_last_season_adjusted_points']}")
            print(f"Average Points/GW - Current: {solution['avg_current_points_per_gw']}, Last Season: {solution['avg_last_season_points_per_gw']}")
            print(f"Last Season Weighting: {solution['last_season_weighting']}")
            
        # Show bench budget info if enabled
        if solution.get('bench_budget') is not None:
            bench_cost = solution['bench_stats'].get('total_price', 0.0)
            print(f"Bench Budget: £{bench_cost}m / £{solution['bench_budget']}m")
            
        if solution.get('optimize_starting_xi'):
            print("Optimization Mode: Starting XI points only")
            
        print(f"Solver Status: {solution['solver_status']}")
        
        # Show starting XI and bench breakdown if available
        if solution.get('starting_xi_stats'):
            starting_xi_stats = solution['starting_xi_stats']
            bench_stats = solution['bench_stats']
            
            print(f"\nSTARTING XI ({starting_xi_stats['formation']}):")
            print(f"  Cost: £{starting_xi_stats['total_price']}m")
            print(f"  Projected Points: {starting_xi_stats['total_proj_points']}")
            if solution.get('fixture_weighting', 0.0) > 0:
                print(f"  Fixture-Adjusted Points: {starting_xi_stats['total_fixture_adjusted_points']}")
            if solution.get('last_season_weighting', 0.0) > 0:
                print(f"  Last Season Adjusted Points: {starting_xi_stats['total_last_season_adjusted_points']}")
            
            print(f"\nBENCH ({bench_stats['count']} players):")
            print(f"  Cost: £{bench_stats['total_price']}m")
            print(f"  Projected Points: {bench_stats['total_proj_points']}")
            if solution.get('fixture_weighting', 0.0) > 0:
                print(f"  Fixture-Adjusted Points: {bench_stats['total_fixture_adjusted_points']}")
            if solution.get('last_season_weighting', 0.0) > 0:
                print(f"  Last Season Adjusted Points: {bench_stats['total_last_season_adjusted_points']}")
        
        print("\nTEAM COMPOSITION:")
        print("-" * 60)
        
        for pos in ['GKP', 'DEF', 'MID', 'FWD']:
            players = solution['by_position'][pos]
            print(f"\n{pos} ({len(players)}):")
            for player in players:
                # Check if player is in starting XI
                starter_indicator = ""
                if solution.get('starting_xi_players'):
                    starting_xi_ids = [p['id'] for p in solution['starting_xi_players']]
                    if player['id'] in starting_xi_ids:
                        starter_indicator = " [XI]"
                    else:
                        starter_indicator = " [B] "
                
                # Build the display string dynamically based on enabled features
                base_info = f"  {player['name']:<20}{starter_indicator:<5} {player['team_name']:<4} £{player['price']:<4}m {player['proj_points']:<4} pts"
                
                adjustments = []
                if solution.get('fixture_weighting', 0.0) > 0:
                    adjustments.append(f"fix: {player['fixture_adjusted_points']:<4.1f}")
                    
                if solution.get('last_season_weighting', 0.0) > 0:
                    current_rate = player['current_points_per_gw']
                    last_rate = player['last_season_points_per_gw']
                    final_points = player['last_season_adjusted_points']
                    adjustments.append(f"hist: {final_points:<4.1f} (curr:{current_rate:.1f}/gw, last:{last_rate:.1f}/gw)")
                
                fixture_info = f"Diff: {player['avg_fixture_difficulty_5']:<3.1f} | Next: {player['next_3_fixtures']}"
                
                if adjustments:
                    adj_str = " (" + ", ".join(adjustments) + ")"
                    print(f"{base_info}{adj_str} | {fixture_info}")
                else:
                    print(f"{base_info} | {fixture_info}")
        
        print(f"\nTEAM DISTRIBUTION:")
        print("-" * 30)
        for team, count in sorted(solution['by_team_counts'].items()):
            print(f"{team}: {count} player{'s' if count > 1 else ''}")
        
        # Validation
        validation = self.validate_solution(solution)
        print(f"\nVALIDATION:")
        print("-" * 20)
        print(f"Valid Solution: {'✓' if validation['valid'] else '✗'}")
        print(f"Squad Size (15): {'✓' if validation['squad_size'] else '✗'}")
        print(f"Budget (≤£100m): {'✓' if validation['budget'] else '✗'}")
        print(f"Positions (2-5-5-3): {'✓' if validation['positions'] else '✗'}")
        print(f"Club Limits (≤3): {'✓' if validation['club_limits'] else '✗'}")
        
        # Show additional validations if applicable
        if solution.get('starting_xi_players'):
            formation = solution.get('starting_xi_stats', {}).get('formation', 'N/A')
            print(f"Starting XI ({formation}): {'✓' if validation['starting_xi_valid'] else '✗'}")
            
        if solution.get('bench_budget') is not None:
            print(f"Bench Budget: {'✓' if validation['bench_budget_valid'] else '✗'}")


def run_test():
    """Run a simple test with dummy data to verify the algorithm."""
    print("\n" + "="*50)
    print("RUNNING TEST WITH DUMMY DATA")
    print("="*50)
    
    # Create minimal test data
    test_data = pd.DataFrame({
        'id': [1, 2, 3, 4, 5, 6],
        'name': ['GK1', 'GK2', 'DEF1', 'MID1', 'FWD1', 'FWD2'],
        'position': ['GKP', 'GKP', 'DEF', 'MID', 'FWD', 'FWD'],
        'team': [1, 2, 1, 2, 1, 2],
        'price': [4.5, 4.0, 4.0, 4.5, 4.5, 5.0],
        'proj_points': [50, 40, 60, 80, 70, 90],
        'team_name': ['T1', 'T2', 'T1', 'T2', 'T1', 'T2']
    })
    
    # Test constraints: Budget=10.0, need GKP=1, DEF=1, MID=1, FWD=1, squad_size=4, club_limit=2
    solver = pywraplp.Solver.CreateSolver('SCIP')
    x = {i: solver.IntVar(0, 1, f'x_{i}') for i in test_data.index}
    
    # Modified constraints for test
    solver.Add(sum(x[i] for i in test_data.index) == 4)  # Squad size = 4
    solver.Add(sum(test_data.loc[i, 'price'] * x[i] for i in test_data.index) <= 18.0)  # Budget
    
    # Position requirements (1 each)
    for pos in ['GKP', 'DEF', 'MID', 'FWD']:
        pos_players = test_data[test_data['position'] == pos].index
        if len(pos_players) > 0:
            solver.Add(sum(x[i] for i in pos_players) >= 1)
    
    # Club limit
    for team_id in test_data['team'].unique():
        team_players = test_data[test_data['team'] == team_id].index
        solver.Add(sum(x[i] for i in team_players) <= 2)
    
    # Maximize points
    solver.Maximize(sum(test_data.loc[i, 'proj_points'] * x[i] for i in test_data.index))
    
    status = solver.Solve()
    
    if status == pywraplp.Solver.OPTIMAL:
        selected = [i for i in test_data.index if x[i].solution_value() > 0.5]
        selected_players = test_data.loc[selected]
        
        print("Test PASSED! ✓")
        print(f"Selected players: {selected_players['name'].tolist()}")
        print(f"Total cost: £{selected_players['price'].sum()}m")
        print(f"Total points: {selected_players['proj_points'].sum()}")
        print(f"Team distribution: {selected_players['team_name'].value_counts().to_dict()}")
        return True
    else:
        print("Test FAILED! ✗")
        print("Could not find optimal solution for test data")
        return False


def main():
    parser = argparse.ArgumentParser(description='FPL Team Selection Optimizer')
    parser.add_argument('--objective', choices=['max_points', 'max_spend'], 
                       default='max_points', help='Optimization objective')
    parser.add_argument('--data-dir', default='fpl_data/fpl_data', 
                       help='Directory containing FPL data files')
    parser.add_argument('--test', action='store_true', 
                       help='Run test with dummy data')
    parser.add_argument('--allow-rotation', action='store_true',
                       help='Allow rotation players (who haven\'t started all games)')
    parser.add_argument('--no-max-one-per-team-position', action='store_true',
                       help='Disable max 1 player per team per position constraint (default: enabled)')
    parser.add_argument('--allow-injury-risk', action='store_true',
                       help='Allow players with injury concerns (default: exclude doubtful/injured players)')
    parser.add_argument('--fixture-weighting', type=float, default=0.0, metavar='WEIGHT',
                       help='Weight for fixture difficulty (0.0-1.0, higher = more fixture influence, default: 0.0)')
    parser.add_argument('--last-season-weighting', type=float, default=0.0, metavar='WEIGHT',
                       help='Weight for last season performance (0.0-1.0, higher = more historical influence, default: 0.0)')
    parser.add_argument('--bench-budget', type=float, default=None, metavar='BUDGET',
                       help='Maximum budget for bench players in millions (e.g., 20.0 for £20M, default: no limit)')
    parser.add_argument('--optimize-starting-xi', action='store_true',
                       help='Optimize starting XI points only, ignore bench player points (default: optimize total squad)')
    
    args = parser.parse_args()
    
    if args.test:
        run_test()
        return
    
    try:
        # Initialize the selector
        selector = FPLTeamSelector(args.data_dir)
        
        # Validate weighting parameters
        if not (0.0 <= args.fixture_weighting <= 1.0):
            print("Error: fixture-weighting must be between 0.0 and 1.0")
            sys.exit(1)
            
        if not (0.0 <= args.last_season_weighting <= 1.0):
            print("Error: last-season-weighting must be between 0.0 and 1.0")
            sys.exit(1)
            
        if args.bench_budget is not None and args.bench_budget < 0.0:
            print("Error: bench-budget must be non-negative")
            sys.exit(1)
        
        # Solve the optimization problem
        solution = selector.solve_team_selection(
            objective=args.objective,
            require_all_starts=not args.allow_rotation,
            max_per_team_per_position=not args.no_max_one_per_team_position,
            exclude_injury_risk=not args.allow_injury_risk,
            fixture_weighting=args.fixture_weighting,
            last_season_weighting=args.last_season_weighting,
            bench_budget=args.bench_budget,
            optimize_starting_xi=args.optimize_starting_xi
        )
        
        if solution:
            selector.print_solution(solution)
        else:
            print("Failed to find a solution!")
            sys.exit(1)
            
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()